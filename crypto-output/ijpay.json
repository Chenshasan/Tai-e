[ {
  "judgeType" : "Influencing Factor",
  "message" : "Should process the return value of this method instead of returning directly",
  "calleeMethod" : "<com.jpay.ext.kit.HttpKit$TrustAnyTrustManager: java.security.cert.X509Certificate[] getAcceptedIssuers()>",
  "subSignature" : "java.security.cert.X509Certificate[] getAcceptedIssuers()"
}, {
  "judgeType" : "Pattern Match",
  "message" : "The pattern is not matched for the API",
  "sourceStmt" : "$-c2 = \"RSA/ECB/PKCS1Padding\"",
  "sourceMethod" : "<com.jpay.secure.RSAUtils: java.lang.String decryptByPrivateKey(java.lang.String,java.lang.String)>",
  "callSite" : "<com.jpay.secure.RSAUtils: java.lang.String decryptByPrivateKey(java.lang.String,java.lang.String,java.lang.String)>[12@L201] cipher = invokestatic javax.crypto.Cipher.getInstance(fillMode)",
  "var" : "fillMode",
  "constantValue" : "RSA/ECB/PKCS1Padding",
  "calleeMethod" : "<javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>",
  "subSignature" : "java.lang.String decryptByPrivateKey(java.lang.String,java.lang.String,java.lang.String)"
}, {
  "judgeType" : "Pattern Match",
  "message" : "The pattern is not matched for the API",
  "sourceStmt" : "$-c2 = \"RSA/ECB/OAEPWITHSHA-1ANDMGF1PADDING\"",
  "sourceMethod" : "<com.jpay.secure.RSAUtils: java.lang.String decryptByPrivateKeyByWx(java.lang.String,java.lang.String)>",
  "callSite" : "<com.jpay.secure.RSAUtils: java.lang.String decryptByPrivateKey(java.lang.String,java.lang.String,java.lang.String)>[12@L201] cipher = invokestatic javax.crypto.Cipher.getInstance(fillMode)",
  "var" : "fillMode",
  "constantValue" : "RSA/ECB/OAEPWITHSHA-1ANDMGF1PADDING",
  "calleeMethod" : "<javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>",
  "subSignature" : "java.lang.String decryptByPrivateKey(java.lang.String,java.lang.String,java.lang.String)"
}, {
  "judgeType" : "Pattern Match",
  "message" : "The pattern is not matched for the API",
  "sourceStmt" : "$-c2 = \"RSA/ECB/PKCS1Padding\"",
  "sourceMethod" : "<com.jpay.secure.RSAUtils: java.lang.String encryptByPublicKey(java.lang.String,java.lang.String)>",
  "callSite" : "<com.jpay.secure.RSAUtils: java.lang.String encryptByPublicKey(java.lang.String,java.lang.String,java.lang.String)>[10@L149] cipher = invokestatic javax.crypto.Cipher.getInstance(fillMode)",
  "var" : "fillMode",
  "constantValue" : "RSA/ECB/PKCS1Padding",
  "calleeMethod" : "<javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>",
  "subSignature" : "java.lang.String encryptByPublicKey(java.lang.String,java.lang.String,java.lang.String)"
}, {
  "judgeType" : "Pattern Match",
  "message" : "The pattern is not matched for the API",
  "sourceStmt" : "$-c2 = \"RSA/ECB/OAEPWITHSHA-1ANDMGF1PADDING\"",
  "sourceMethod" : "<com.jpay.secure.RSAUtils: java.lang.String encryptByPublicKeyByWx(java.lang.String,java.lang.String)>",
  "callSite" : "<com.jpay.secure.RSAUtils: java.lang.String encryptByPublicKey(java.lang.String,java.lang.String,java.lang.String)>[10@L149] cipher = invokestatic javax.crypto.Cipher.getInstance(fillMode)",
  "var" : "fillMode",
  "constantValue" : "RSA/ECB/OAEPWITHSHA-1ANDMGF1PADDING",
  "calleeMethod" : "<javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>",
  "subSignature" : "java.lang.String encryptByPublicKey(java.lang.String,java.lang.String,java.lang.String)"
}, {
  "judgeType" : "Influencing Factor",
  "message" : "Should use the var: session",
  "calleeMethod" : "<com.jpay.ext.kit.HttpKit$TrustAnyHostnameVerifier: boolean verify(java.lang.String,javax.net.ssl.SSLSession)>",
  "subSignature" : "boolean verify(java.lang.String,javax.net.ssl.SSLSession)"
}, {
  "judgeType" : "Pattern Match",
  "message" : "The pattern is not matched for the API",
  "sourceStmt" : "$-c1 = \"MD5\"",
  "sourceMethod" : "<com.jpay.ext.kit.HashKit: java.lang.String md5(java.lang.String)>",
  "callSite" : "<com.jpay.ext.kit.HashKit: java.lang.String hash(java.lang.String,java.lang.String)>[0@L33] md = invokestatic java.security.MessageDigest.getInstance(algorithm)",
  "var" : "algorithm",
  "constantValue" : "MD5",
  "calleeMethod" : "<java.security.MessageDigest: java.security.MessageDigest getInstance(java.lang.String)>",
  "subSignature" : "java.lang.String hash(java.lang.String,java.lang.String)"
}, {
  "judgeType" : "Pattern Match",
  "message" : "The pattern is not matched for the API",
  "sourceStmt" : "$-c1 = \"SHA-1\"",
  "sourceMethod" : "<com.jpay.ext.kit.HashKit: java.lang.String sha1(java.lang.String)>",
  "callSite" : "<com.jpay.ext.kit.HashKit: java.lang.String hash(java.lang.String,java.lang.String)>[0@L33] md = invokestatic java.security.MessageDigest.getInstance(algorithm)",
  "var" : "algorithm",
  "constantValue" : "SHA-1",
  "calleeMethod" : "<java.security.MessageDigest: java.security.MessageDigest getInstance(java.lang.String)>",
  "subSignature" : "java.lang.String hash(java.lang.String,java.lang.String)"
}, {
  "judgeType" : "Pattern Match",
  "message" : "The pattern is not matched for the API",
  "sourceStmt" : "$-c3 = \"SHA-1\"",
  "sourceMethod" : "<com.jpay.unionpay.SecureUtil: byte[] sha1(byte[])>",
  "callSite" : "<com.jpay.unionpay.SecureUtil: byte[] sha1(byte[])>[1@L167] md = invokestatic java.security.MessageDigest.getInstance($-c3)",
  "var" : "$-c3",
  "constantValue" : "SHA-1",
  "calleeMethod" : "<java.security.MessageDigest: java.security.MessageDigest getInstance(java.lang.String)>",
  "subSignature" : "byte[] sha1(byte[])"
}, {
  "judgeType" : "Pattern Match",
  "message" : "The pattern is not matched for the API",
  "sourceStmt" : "$-c5 = \"SHA1withRSA\"",
  "sourceMethod" : "<com.jpay.unionpay.SecureUtil: boolean validateSignBySoft(java.security.PublicKey,byte[],byte[])>",
  "callSite" : "<com.jpay.unionpay.SecureUtil: boolean validateSignBySoft(java.security.PublicKey,byte[],byte[])>[2@L301] st = invokestatic java.security.Signature.getInstance($-c5, $-c4)",
  "var" : "$-c5",
  "constantValue" : "SHA1withRSA",
  "calleeMethod" : "<java.security.Signature: java.security.Signature getInstance(java.lang.String,java.lang.String)>",
  "subSignature" : "boolean validateSignBySoft(java.security.PublicKey,byte[],byte[])"
}, {
  "judgeType" : "Pattern Match",
  "message" : "The pattern is not matched for the API",
  "sourceStmt" : "$-c5 = \"SHA1withRSA\"",
  "sourceMethod" : "<com.jpay.unionpay.SecureUtil: byte[] signBySoft(java.security.PrivateKey,byte[])>",
  "callSite" : "<com.jpay.unionpay.SecureUtil: byte[] signBySoft(java.security.PrivateKey,byte[])>[2@L276] st = invokestatic java.security.Signature.getInstance($-c5, $-c4)",
  "var" : "$-c5",
  "constantValue" : "SHA1withRSA",
  "calleeMethod" : "<java.security.Signature: java.security.Signature getInstance(java.lang.String,java.lang.String)>",
  "subSignature" : "byte[] signBySoft(java.security.PrivateKey,byte[])"
}, {
  "judgeType" : "CompositeRule",
  "issues" : [ {
    "judgeType" : "Number Size",
    "message" : "The number size is not allowed for the API",
    "sourceStmt" : "$-c9 = 1024",
    "sourceMethod" : "<com.jpay.secure.RSAUtils: java.util.Map getKeys()>",
    "callSite" : "<com.jpay.secure.RSAUtils: java.util.Map getKeys()>[3@L53] invokevirtual keyPairGen.initialize($-c9)",
    "var" : "$-c9",
    "constantValue" : "1024",
    "calleeMethod" : "<java.security.KeyPairGenerator: void initialize(int)>",
    "numberSize" : "2048-10000",
    "subSignature" : "java.util.Map getKeys()"
  } ]
} ]